{"version":3,"file":"xsrf.js","sourceRoot":"","sources":["../../../../../packages/common/http/src/xsrf.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,QAAQ,EAAE,iBAAiB,IAAI,gBAAgB,EAAC,MAAM,iBAAiB,CAAC;AAChF,OAAO,EAAC,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAC,MAAM,eAAe,CAAC;;AAQ9E,aAAa,gBAAgB,GAAG,IAAI,cAAc,CAAS,kBAAkB,CAAC,CAAC;;AAC/E,aAAa,gBAAgB,GAAG,IAAI,cAAc,CAAS,kBAAkB,CAAC,CAAC;;;;;;;AAO/E,MAAM,OAAgB,sBAAsB;CAO3C;;;;;;;;;;;;;;AAMD,MAAM,OAAO,uBAAuB;;;;;;IASlC,YAC8B,GAAQ,EAA+B,QAAgB,EAC/C,UAAkB;QAD1B,QAAG,GAAH,GAAG,CAAK;QAA+B,aAAQ,GAAR,QAAQ,CAAQ;QAC/C,eAAU,GAAV,UAAU,CAAQ;gCAVrB,EAAE;yBACJ,IAAI;;;;QAKrC,kBAAqB,CAAC,CAAC;KAIqC;;;;IAE5D,QAAQ;QACN,IAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;;QACD,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,CAAC;QAC3C,IAAI,YAAY,KAAK,IAAI,CAAC,gBAAgB,EAAE;YAC1C,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,IAAI,CAAC,SAAS,GAAG,gBAAgB,CAAC,YAAY,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACjE,IAAI,CAAC,gBAAgB,GAAG,YAAY,CAAC;SACtC;QACD,OAAO,IAAI,CAAC,SAAS,CAAC;KACvB;;;YAzBF,UAAU;;;;4CAWJ,MAAM,SAAC,QAAQ;yCAAqB,MAAM,SAAC,WAAW;yCACtD,MAAM,SAAC,gBAAgB;;;;;;;;;;;;;;;;;;;;;;AAoB9B,MAAM,OAAO,mBAAmB;;;;;IAC9B,YACY,cAC0B,UAAkB;QAD5C,iBAAY,GAAZ,YAAY;QACc,eAAU,GAAV,UAAU,CAAQ;KAAI;;;;;;IAE5D,SAAS,CAAC,GAAqB,EAAE,IAAiB;;QAChD,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC;;;;;QAKpC,IAAI,GAAG,CAAC,MAAM,KAAK,KAAK,IAAI,GAAG,CAAC,MAAM,KAAK,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC;YAC5E,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE;YAChC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACzB;;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;;QAG3C,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACvD,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,EAAC,OAAO,EAAE,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,EAAC,CAAC,CAAC;SACrE;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;KACzB;;;YAvBF,UAAU;;;;YAGiB,sBAAsB;yCAC3C,MAAM,SAAC,gBAAgB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ÉµparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, PLATFORM_ID} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {HttpHandler} from './backend';\nimport {HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const XSRF_COOKIE_NAME = new InjectionToken<string>('XSRF_COOKIE_NAME');\nexport const XSRF_HEADER_NAME = new InjectionToken<string>('XSRF_HEADER_NAME');\n\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n * @publicApi\n */\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string|null;\n}\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\n@Injectable()\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\n  private lastCookieString: string = '';\n  private lastToken: string|null = null;\n\n  /**\n   * @internal for testing\n   */\n  parseCount: number = 0;\n\n  constructor(\n      @Inject(DOCUMENT) private doc: any, @Inject(PLATFORM_ID) private platform: string,\n      @Inject(XSRF_COOKIE_NAME) private cookieName: string) {}\n\n  getToken(): string|null {\n    if (this.platform === 'server') {\n      return null;\n    }\n    const cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\n@Injectable()\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n  constructor(\n      private tokenService: HttpXsrfTokenExtractor,\n      @Inject(XSRF_HEADER_NAME) private headerName: string) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n        lcUrl.startsWith('https://')) {\n      return next.handle(req);\n    }\n    const token = this.tokenService.getToken();\n\n    // Be careful not to overwrite an existing header of the same name.\n    if (token !== null && !req.headers.has(this.headerName)) {\n      req = req.clone({headers: req.headers.set(this.headerName, token)});\n    }\n    return next.handle(req);\n  }\n}\n"]}