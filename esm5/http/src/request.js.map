{"version":3,"file":"request.js","sourceRoot":"","sources":["../../../../../../packages/common/http/src/request.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,WAAW,EAAC,MAAM,WAAW,CAAC;AACtC,OAAO,EAAC,UAAU,EAAC,MAAM,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;;;AAkBpC,SAAS,aAAa,CAAC,MAAc;IACnC,QAAQ,MAAM,EAAE;QACd,KAAK,QAAQ,CAAC;QACd,KAAK,KAAK,CAAC;QACX,KAAK,MAAM,CAAC;QACZ,KAAK,SAAS,CAAC;QACf,KAAK,OAAO;YACV,OAAO,KAAK,CAAC;QACf;YACE,OAAO,IAAI,CAAC;KACf;CACF;;;;;;;;AAOD,SAAS,aAAa,CAAC,KAAU;IAC/B,OAAO,OAAO,WAAW,KAAK,WAAW,IAAI,KAAK,YAAY,WAAW,CAAC;CAC3E;;;;;;;;AAOD,SAAS,MAAM,CAAC,KAAU;IACxB,OAAO,OAAO,IAAI,KAAK,WAAW,IAAI,KAAK,YAAY,IAAI,CAAC;CAC7D;;;;;;;;AAOD,SAAS,UAAU,CAAC,KAAU;IAC5B,OAAO,OAAO,QAAQ,KAAK,WAAW,IAAI,KAAK,YAAY,QAAQ,CAAC;CACrE;;;;;;;;;;;;AAYD;;;;;;;;;;;AAAA;IA0EE,qBACI,MAAc,EAAW,GAAW,EAAE,KAMhC,EACN,MAMC;QAbwB,QAAG,GAAH,GAAG,CAAQ;;;;;;;;QAnExC,YAAwB,IAAI,CAAC;;;;;;;QAc7B,sBAAmC,KAAK,CAAC;;;;QAKzC,uBAAoC,KAAK,CAAC;;;;;;;QAQ1C,oBAA4D,MAAM,CAAC;QAsDjE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;;QAGnC,IAAI,OAAO,CAA4B;;;QAIvC,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE;;YAE1C,IAAI,CAAC,IAAI,GAAG,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,mBAAC,KAAU,EAAC,CAAC,CAAC,IAAI,CAAC;YACtD,OAAO,GAAG,MAAM,CAAC;SAClB;aAAM;;YAEL,OAAO,qBAAG,KAAwB,CAAA,CAAC;SACpC;;QAGD,IAAI,OAAO,EAAE;;YAEX,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC;YAC/C,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC;;YAGjD,IAAI,CAAC,CAAC,OAAO,CAAC,YAAY,EAAE;gBAC1B,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;aAC1C;;YAGD,IAAI,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;gBACrB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;aAChC;YAED,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE;gBACpB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;aAC9B;SACF;;QAGD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;SAClC;;QAGD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,IAAI,CAAC,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;YAC/B,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC;SAC1B;aAAM;;YAEL,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YACtC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;;gBAEvB,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC;aAC1B;iBAAM;;gBAEL,IAAM,IAAI,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;;gBAQ9B,IAAM,GAAG,GAAW,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;gBAC3E,IAAI,CAAC,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC;aACzC;SACF;KACF;IAED;;;OAGG;;;;;;IACH,mCAAa;;;;;IAAb;;QAEE,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;YACtB,OAAO,IAAI,CAAC;SACb;;;QAGD,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;YACtE,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;YACjC,OAAO,IAAI,CAAC,IAAI,CAAC;SAClB;;QAED,IAAI,IAAI,CAAC,IAAI,YAAY,UAAU,EAAE;YACnC,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;SAC7B;;QAED,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,SAAS;YAC/D,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC5B,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAClC;;QAED,OAAO,mBAAC,IAAI,CAAC,IAAW,EAAC,CAAC,QAAQ,EAAE,CAAC;KACtC;IAED;;;;;OAKG;;;;;;;;IACH,6CAAuB;;;;;;;IAAvB;;QAEE,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;YACtB,OAAO,IAAI,CAAC;SACb;;QAED,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACzB,OAAO,IAAI,CAAC;SACb;;;QAGD,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACrB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;SAC/B;;QAED,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC5B,OAAO,IAAI,CAAC;SACb;;;QAGD,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;YACjC,OAAO,YAAY,CAAC;SACrB;;QAED,IAAI,IAAI,CAAC,IAAI,YAAY,UAAU,EAAE;YACnC,OAAO,iDAAiD,CAAC;SAC1D;;QAED,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ;YAC9D,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC5B,OAAO,kBAAkB,CAAC;SAC3B;;QAED,OAAO,IAAI,CAAC;KACb;;;;;IA2BD,2BAAK;;;;IAAL,UAAM,MAWA;QAXA,uBAAA,EAAA,WAWA;;QAGJ,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;;QAC5C,IAAM,GAAG,GAAG,MAAM,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC;;QACnC,IAAM,YAAY,GAAG,MAAM,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC;;QAM9D,IAAM,IAAI,GAAG,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;QAInE,IAAM,eAAe,GACjB,CAAC,MAAM,CAAC,eAAe,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;;QAC3F,IAAM,cAAc,GAChB,CAAC,MAAM,CAAC,cAAc,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;;QAIxF,IAAI,OAAO,GAAG,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC;;QAC7C,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;;QAG1C,IAAI,MAAM,CAAC,UAAU,KAAK,SAAS,EAAE;;YAEnC,OAAO;gBACH,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;qBACzB,MAAM,CAAC,UAAC,OAAO,EAAE,IAAI,IAAK,OAAA,OAAO,CAAC,GAAG,CAAC,IAAI,qBAAE,MAAM,CAAC,UAAU,GAAG,IAAI,EAAE,EAA5C,CAA4C,EAAE,OAAO,CAAC,CAAC;SAC3F;;QAGD,IAAI,MAAM,CAAC,SAAS,EAAE;;YAEpB,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;iBACxB,MAAM,CAAC,UAAC,MAAM,EAAE,KAAK,IAAK,OAAA,MAAM,CAAC,GAAG,CAAC,KAAK,qBAAE,MAAM,CAAC,SAAS,GAAG,KAAK,EAAE,EAA5C,CAA4C,EAAE,MAAM,CAAC,CAAC;SAC/F;;QAGD,OAAO,IAAI,WAAW,CAClB,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE;YACI,MAAM,QAAA,EAAE,OAAO,SAAA,EAAE,cAAc,gBAAA,EAAE,YAAY,cAAA,EAAE,eAAe,iBAAA;SACjE,CAAC,CAAC;KAC3B;sBAjYH;IAkYC,CAAA;;;;;;;;;;;;AArTD,uBAqTC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\n\n/**\n * Construction interface for `HttpRequest`s.\n *\n * All values are optional and will override default values if provided.\n */\ninterface HttpRequestInit {\n  headers?: HttpHeaders;\n  reportProgress?: boolean;\n  params?: HttpParams;\n  responseType?: 'arraybuffer'|'blob'|'json'|'text';\n  withCredentials?: boolean;\n}\n\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method: string): boolean {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\n\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n * @publicApi\n */\nexport class HttpRequest<T> {\n  /**\n   * The request body, or `null` if one isn't set.\n   *\n   * Bodies are not enforced to be immutable, as they can include a reference to any\n   * user-defined data type. However, interceptors should take care to preserve\n   * idempotence by treating them as such.\n   */\n  readonly body: T|null = null;\n\n  /**\n   * Outgoing headers for this request.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly headers !: HttpHeaders;\n\n  /**\n   * Whether this request should be made in a way that exposes progress events.\n   *\n   * Progress events are expensive (change detection runs on each event) and so\n   * they should only be requested if the consumer intends to monitor them.\n   */\n  readonly reportProgress: boolean = false;\n\n  /**\n   * Whether this request should be sent with outgoing credentials (cookies).\n   */\n  readonly withCredentials: boolean = false;\n\n  /**\n   * The expected response type of the server.\n   *\n   * This is used to parse the response appropriately before returning it to\n   * the requestee.\n   */\n  readonly responseType: 'arraybuffer'|'blob'|'json'|'text' = 'json';\n\n  /**\n   * The outgoing HTTP request method.\n   */\n  readonly method: string;\n\n  /**\n   * Outgoing URL parameters.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly params !: HttpParams;\n\n  /**\n   * The outgoing URL with all URL parameters set.\n   */\n  readonly urlWithParams: string;\n\n  constructor(method: 'DELETE'|'GET'|'HEAD'|'JSONP'|'OPTIONS', url: string, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(method: 'POST'|'PUT'|'PATCH', url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(method: string, url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(\n      method: string, readonly url: string, third?: T|{\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }|null,\n      fourth?: {\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }) {\n    this.method = method.toUpperCase();\n    // Next, need to figure out which argument holds the HttpRequestInit\n    // options, if any.\n    let options: HttpRequestInit|undefined;\n\n    // Check whether a body argument is expected. The only valid way to omit\n    // the body argument is to use a known no-body method like GET.\n    if (mightHaveBody(this.method) || !!fourth) {\n      // Body is the third argument, options are the fourth.\n      this.body = (third !== undefined) ? third as T : null;\n      options = fourth;\n    } else {\n      // No body required, options are the third argument. The body stays null.\n      options = third as HttpRequestInit;\n    }\n\n    // If options have been passed, interpret them.\n    if (options) {\n      // Normalize reportProgress and withCredentials.\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n\n      // Override default response type of 'json' if one is provided.\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n\n      // Override headers if they're provided.\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n\n      if (!!options.params) {\n        this.params = options.params;\n      }\n    }\n\n    // If no headers have been passed in, construct a new HttpHeaders instance.\n    if (!this.headers) {\n      this.headers = new HttpHeaders();\n    }\n\n    // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      // Encode the parameters to a string in preparation for inclusion in the URL.\n      const params = this.params.toString();\n      if (params.length === 0) {\n        // No parameters, the visible URL is just the URL given at creation time.\n        this.urlWithParams = url;\n      } else {\n        // Does the URL already have query parameters? Look for '?'.\n        const qIdx = url.indexOf('?');\n        // There are 3 cases to handle:\n        // 1) No existing parameters -> append '?' followed by params.\n        // 2) '?' exists and is followed by existing query string ->\n        //    append '&' followed by params.\n        // 3) '?' exists at the end of the url -> append params directly.\n        // This basically amounts to determining the character, if any, with\n        // which to join the URL and parameters.\n        const sep: string = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n\n  /**\n   * Transform the free-form body into a serialized format suitable for\n   * transmission to the server.\n   */\n  serializeBody(): ArrayBuffer|Blob|FormData|string|null {\n    // If no body is present, no need to serialize it.\n    if (this.body === null) {\n      return null;\n    }\n    // Check whether the body is already in a serialized form. If so,\n    // it can just be returned directly.\n    if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n        typeof this.body === 'string') {\n      return this.body;\n    }\n    // Check whether the body is an instance of HttpUrlEncodedParams.\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    // Check whether the body is an object or array, and serialize with JSON if so.\n    if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n        Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    // Fall back on toString() for everything else.\n    return (this.body as any).toString();\n  }\n\n  /**\n   * Examine the body and attempt to infer an appropriate MIME type\n   * for it.\n   *\n   * If no such type can be inferred, this method will return `null`.\n   */\n  detectContentTypeHeader(): string|null {\n    // An empty body has no content type.\n    if (this.body === null) {\n      return null;\n    }\n    // FormData bodies rely on the browser's content type assignment.\n    if (isFormData(this.body)) {\n      return null;\n    }\n    // Blobs usually have their own content type. If it doesn't, then\n    // no type can be inferred.\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    // Array buffers have unknown contents and thus no type can be inferred.\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    // Technically, strings could be a form of JSON data, but it's safe enough\n    // to assume they're plain strings.\n    if (typeof this.body === 'string') {\n      return 'text/plain';\n    }\n    // `HttpUrlEncodedParams` has its own content-type.\n    if (this.body instanceof HttpParams) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    // Arrays, objects, and numbers will be encoded as JSON.\n    if (typeof this.body === 'object' || typeof this.body === 'number' ||\n        Array.isArray(this.body)) {\n      return 'application/json';\n    }\n    // No type could be inferred.\n    return null;\n  }\n\n  clone(): HttpRequest<T>;\n  clone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: T|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<T>;\n  clone<V>(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: V|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<V>;\n  clone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: any|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string};\n  } = {}): HttpRequest<any> {\n    // For method, url, and responseType, take the current value unless\n    // it is overridden in the update hash.\n    const method = update.method || this.method;\n    const url = update.url || this.url;\n    const responseType = update.responseType || this.responseType;\n\n    // The body is somewhat special - a `null` value in update.body means\n    // whatever current body is present is being overridden with an empty\n    // body, whereas an `undefined` value in update.body implies no\n    // override.\n    const body = (update.body !== undefined) ? update.body : this.body;\n\n    // Carefully handle the boolean options to differentiate between\n    // `false` and `undefined` in the update args.\n    const withCredentials =\n        (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n    const reportProgress =\n        (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n\n    // Headers and params may be appended to if `setHeaders` or\n    // `setParams` are used.\n    let headers = update.headers || this.headers;\n    let params = update.params || this.params;\n\n    // Check whether the caller has asked to add headers.\n    if (update.setHeaders !== undefined) {\n      // Set every requested header.\n      headers =\n          Object.keys(update.setHeaders)\n              .reduce((headers, name) => headers.set(name, update.setHeaders ![name]), headers);\n    }\n\n    // Check whether the caller has asked to set params.\n    if (update.setParams) {\n      // Set every requested param.\n      params = Object.keys(update.setParams)\n                   .reduce((params, param) => params.set(param, update.setParams ![param]), params);\n    }\n\n    // Finally, construct the new HttpRequest using the pieces from above.\n    return new HttpRequest(\n        method, url, body, {\n                               params, headers, reportProgress, responseType, withCredentials,\n                           });\n  }\n}\n"]}